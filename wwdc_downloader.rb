#!/usr/bin/env ruby

require 'json'
require 'pathname'
require 'uri'

# https://developer.apple.com/videos/all-videos/

# {
# 'year': 'wwdc2021', 'session': '10021',
# }
$urlInfo = nil
$pageInfo = nil

def exitWithMessage(message)
    puts message
    exit
end

def exitWithHelp()
    exitWithMessage("ruby {name}.rb {URL}")
end

# download file and parse
# eg: https://developer.apple.com/videos/play/wwdc2021/10021/
# { "title": "xxx", "m3u8_url": "", "mp4_downloads": [],  "pdf_downloads": []}
def loadPageInfo(url)
    content = `curl #{url}`
    exitWithMessage("Cannot load page content: #{url}") if content == nil
    
    titleMatch = /<title>([^$]+)<\/title>$/.match(content)
    exitWithMessage("Cannot find title from content of url: #{url}") if titleMatch == nil

    m3u8Match = /<meta property="og:video" content="([^"]+\.m3u8)"/.match(content)
    exitWithMessage("Cannot find m3u8 url from content of url: #{url}") if m3u8Match == nil

    # mp4
    mp4DownloadsPattern = /<a [^>]*href="([^"]+\.mp4(\?[^"]*)?)">([^<]+)<\/a>/
    # pdf
    pdfDownloadsPattern = /<a [^>]*href="([^"]+\.pdf(\?[^"]*)?)">([^<]+)<\/a>/

    mp4DownloadsMatches = content.scan(mp4DownloadsPattern)
    pdfDownloadsMatches = content.scan(pdfDownloadsPattern)

    mp4Downloads = []
    mp4DownloadsMatches.each do |match|
        url = match.first
        filename = File.basename(URI.parse(url).path)
        info = {
            'title' => match.last,
            'url' => url,
            'filename' => filename,
        }
        mp4Downloads.append(info)
    end
    
    pdfDownloads = []
    pdfDownloadsMatches.each do |match|
        url = match.first
        filename = File.basename(URI.parse(url).path)
        info = {
            'title' => match.last,
            'url' => url,
            'filename' => filename,
        }
        pdfDownloads.append(info)
    end

    result = {
        "title" => titleMatch[1],
        "m3u8_url" => m3u8Match[1],
        "mp4_downloads" => mp4Downloads,
        "pdf_downloads" => pdfDownloads,
    }
    return result
end

exitWithHelp if ARGV.empty?

$url = ARGV[0]

def extractURLInfo(url)
    pattern = /https?:\/\/developer\.apple\.com\/videos\/play\/(wwdc\d+)\/(\d+)\/?/
    match = pattern.match(url)
    return if match == nil
    puts "match: #{match[1]}"
    return {
        "year" => match[1],
        "session" => match[2],
    }
end

$urlInfo = extractURLInfo($url)

exitWithHelp if $urlInfo == nil

puts "Loading #{$url}"
puts $urlInfo

$pageInfo = loadPageInfo($url)
puts $pageInfo

puts "Preparing data"
$dataDir = File.join(__dir__, "#{$urlInfo["year"]}_#{$urlInfo["session"]}")
puts "Data dir: #{$dataDir}"
readMePath = File.join($dataDir, "README.md")
pageM3u8Path = File.join($dataDir, "page.m3u8")
pageJSONPath = File.join($dataDir, "page.json")

`mkdir -p "#{$dataDir}"`
`touch "#{readMePath}"`

puts "Loading & Saving m3u8"
puts "\t url: #{$pageInfo['m3u8_url']}"
puts "\t path: #{pageM3u8Path}"
`curl -o "#{pageM3u8Path}" "#{$pageInfo['m3u8_url']}"`

readMeContent = <<RMContent
# Info

- Title:  #{$pageInfo['title']}
- Year: #{$urlInfo['year']}
- Session: #{$urlInfo['session']}
- URL: #{$url}
- M3U8 URL: #{$pageInfo['m3u8_url']}

Generated by [WWDC Downloader](https://github.com/aopod/WWDCDownloader)

RMContent

File.open(readMePath, 'w') { |f|
    f.write(readMeContent)
}

def extractM3U8Parameters(string)
    pattern = /([^=,]+)=([^",]+|"[^"]+")/
    matches = string.scan(pattern)
    exitWithMessage("No matches for #{string}") if matches.empty?
    
    parameters = {}
    matches.each do |match|
        parameters[match[0]] = match[1].tr('"', '')
    end
    return parameters
end

# { "video_list": [ parameters, ... ], "subtitles": [], "audio_mapping": {"id": parameters} }
def parsePageM3U8(path)
    urlCandidatesPattern = /#EXT-X-STREAM-INF:([^\n]+)\n([^\n]+\.m3u8)/
    subtitlesPattern = /#EXT-X-MEDIA:TYPE=SUBTITLES,([^\n$]+)/
    audioCandidatesPattern = /#EXT-X-MEDIA:TYPE=AUDIO,([^\n$]+)/

    content = nil
    File.open(path, 'r') { |f|
        content = f.read
    }
    exitWithMessage("Cannot read page m3u8 at #{path}") if content == nil

    urlCandidatesMatches = content.scan(urlCandidatesPattern)
    subtitlesMatches = content.scan(subtitlesPattern)
    audioCandidatesMatches = content.scan(audioCandidatesPattern)

    exitWithMessage('Has not url candidates') if urlCandidatesMatches.empty?

    videoList = []
    urlCandidatesMatches.each do |component|
        parameters = extractM3U8Parameters(component[0])

        relativePath = component[1]
        filename = Pathname(component[1]).basename.to_s.sub('.m3u8', '.mp4')
        m3u8Url = URI.join($pageInfo['m3u8_url'], relativePath)

        parameters['relative_path'] = relativePath
        parameters['filename'] = filename
        parameters['m3u8_url'] = m3u8Url
        videoList.append(parameters)
    end

    subtitles = []
    subtitlesMatches.each do |component|
        parameters = extractM3U8Parameters(component[0])

        filename = "#{parameters['LANGUAGE']}_subtitle.srt"
        m3u8Filename = "#{parameters['LANGUAGE']}_subtitle.m3u8"
        
        parameters['filename'] = filename
        parameters['m3u8_filename'] = m3u8Filename
        parameters['m3u8_url'] = URI.join($pageInfo['m3u8_url'], parameters['URI'])

        subtitles.append(parameters)
    end

    audioMapping = {}
    audioCandidatesMatches.each do |component|
        parameters = extractM3U8Parameters(component[0])
        parameters['m3u8_url'] = URI.join($pageInfo['m3u8_url'], parameters['URI'])
        audioId = parameters['GROUP-ID']
        audioMapping[audioId] = parameters
    end

    result = {
        'video_list' => videoList,
        'subtitles' => subtitles,
        'audio_mapping' => audioMapping,
    }
    return result
end

$downloadInfo = parsePageM3U8(pageM3u8Path)
exitWithMessage("Cannot parse pageM3U8 at #{pageM3u8Path}") if $downloadInfo == nil

# puts($downloadInfo)
File.open(pageJSONPath, 'w') { |f|
    content = JSON.pretty_generate($downloadInfo)
    f.write(content)
}

puts ""
(["Skip downloading subtitle"] + ($downloadInfo['subtitles'].map {|t| t['filename']}))
    .each_with_index do |val, index|
    puts "- #{index}: #{val}"
end
puts "Select subtitles to download(`,` separate to download multiple subs):"
subtitleSelections = STDIN.gets.chomp.split(',').map { |s| Integer(s.tr(' ', '')) }
subtitleInfoList = []
if subtitleSelections.include? 0
    puts "Skip downloading subtitle"
else
    subtitleSelections.each do |selection|
        selection = selection - 1
        subtitleInfo = $downloadInfo['subtitles'][selection]
        puts "Will download #{selection}: #{subtitleInfo['filename']}"
        subtitleInfoList.append(subtitleInfo)
    end
end

puts ''
(["Skip downloading MP4 video"] + ($pageInfo["mp4_downloads"].map { |t| "#{t['title']}(#{t['filename']})" }))
    .each_with_index do |val, index|
        puts "- #{index}: #{val}"
    end
puts "Select a MP4 video to download:"
mp4Selection = Integer(STDIN.gets.chomp)
mp4DownloadInfo = nil
if mp4Selection == 0
    puts "Skip downloading MP4 video"
else
    mp4Selection = mp4Selection - 1
    mp4DownloadInfo = $pageInfo["mp4_downloads"][mp4Selection]
    puts "Will download #{mp4Selection}: #{mp4DownloadInfo['filename']}(#{mp4DownloadInfo['url']})"
end

(["Skip downloading PDFs"] + ($pageInfo['pdf_downloads'].map {|t| "#{t['title']}(#{t['filename']})" }))
    .each_with_index do |val, index|
    puts "- #{index}: #{val}"
end
puts "Select PDFs to download(`,` separate to download multiple PDFs):"
pdfSelections = STDIN.gets.chomp.split(',').map { |s| Integer(s.tr(' ', '')) }
pdfDownloadsInfoList = []
if pdfSelections.include? 0
    puts "Skip downloading PDFs"
else
    pdfSelections.each do |selection|
        selection = selection - 1
        info = $pageInfo['pdf_downloads'][selection]
        puts "Will download #{selection}: #{info['filename']} (#{info['url']})"
        pdfDownloadsInfoList.append(info)
    end
end

puts ""
(["Skip downloading M3U8 video"] + ($downloadInfo['video_list'].map {|t| "#{t['filename']}(#{t['relative_path']})"}))
    .each_with_index do |val, index|
        puts "- #{index}: #{val}"
    end
puts "Select a M3U8 video to download:"
videoSelection = Integer(STDIN.gets.chomp)
videoInfo = nil
if videoSelection == 0
    puts "Skip downloading M3U8 video"
else
    videoSelection = videoSelection - 1
    videoInfo = $downloadInfo['video_list'][videoSelection]
    puts "Will download #{videoSelection}: #{videoInfo['filename']}(#{videoInfo['relative_path']})"
end

if not subtitleInfoList.empty?
    subtitleInfoList.each do |info|
        filename = info['filename']
        path = File.join($dataDir, filename)
        puts "Downloading subtitle #{filename} to #{path}"
        `ffmpeg -i "#{info['m3u8_url']}" "#{path}"`
    end
end

if not mp4DownloadInfo == nil
    info = mp4DownloadInfo
    filename = info['filename']
    path = File.join($dataDir, filename)
    puts "Downloading MP4(#{info['title']}): #{info['url']}"
    `curl -o "#{path}" "#{info['url']}"`
end

if not pdfDownloadsInfoList.empty?
    pdfDownloadsInfoList.each do |info|
        filename = info['filename']
        path = File.join($dataDir, filename)
        puts "Downloading PDF(#{info['filename']}): #{info['url']}"
        `curl -o "#{path}" "#{info['url']}"`
    end
end

if not videoInfo == nil
    info = videoInfo
    filename = info['filename']
    path = File.join($dataDir, filename)
    puts "Downloading video #{filename} to #{path}"
    audioId = info['AUDIO']
    audioInfo = nil
    if audioId != nil
        audioInfo = $downloadInfo['audio_mapping'][audioId] 
    end
    puts "video: #{info['m3u8_url']}"
    if audioInfo != nil
        puts "audio: #{audioInfo['m3u8_url']}"
        `ffmpeg -i "#{info['m3u8_url']}" -i "#{audioInfo['m3u8_url']}" "#{path}"`
    else
        puts "audio: no audio found"
        `ffmpeg -i "#{info['m3u8_url']}" "#{path}"`
    end
end
